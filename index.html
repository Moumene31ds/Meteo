<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EARTH PRO | Ultimate Edition</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸŒ</text></svg>">

    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;500;700;900&family=Exo+2:wght@300;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        :root {
            --blue: #4facfe;
            --purple: #7028e4;
            --dark: #0a0a0a;
            --glass: rgba(15, 20, 35, 0.85);
            --border: rgba(255, 255, 255, 0.15);
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Cairo', sans-serif; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body { 
            background: #000; overflow: hidden; height: 100vh; color: white; user-select: none; 
            /* Ø®Ù„ÙÙŠØ© Ù…ØªØ¯Ø±Ø¬Ø© Ù„Ø¹Ù…Ù‚ Ø£ÙƒØ¨Ø± */
            background-image: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #000 100%);
        }

        /* Canvas */
        #canvas-container { position: absolute; inset: 0; z-index: 1; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }

        /* UI Layout */
        #ui-layer {
            position: absolute; inset: 0; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; padding: 20px;
        }

        /* HEADER */
        header { 
            display: flex; justify-content: space-between; align-items: center; 
            pointer-events: auto; width: 100%; z-index: 20;
        }

        .brand {
            font-family: 'Exo 2'; font-size: 1.8rem; letter-spacing: 2px; font-weight: 900;
            background: linear-gradient(90deg, #fff, var(--blue));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
        }

        .search-dock {
            background: rgba(0,0,0,0.6); backdrop-filter: blur(15px);
            border: 1px solid var(--border); border-radius: 50px;
            padding: 5px 10px; display: flex; align-items: center; gap: 8px;
            transition: 0.3s; box-shadow: var(--shadow);
        }
        .search-dock:focus-within { border-color: var(--blue); box-shadow: 0 0 25px rgba(79, 172, 254, 0.4); }

        input { background: transparent; border: none; color: white; width: 180px; font-size: 1rem; text-align: right; padding: 5px; }
        .btn-icon { background: none; border: none; color: white; cursor: pointer; padding: 10px; border-radius: 50%; transition: 0.2s; font-size: 1.1rem; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: var(--blue); }
        .btn-icon.recording { color: #ff4444; animation: pulse-red 1.5s infinite; }

        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); } }

        /* DASHBOARD */
        .dashboard {
            margin-top: auto; display: flex; gap: 20px; align-items: flex-end;
            width: 100%; pointer-events: none;
        }

        .panel {
            background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid var(--border); border-radius: 24px;
            padding: 20px; pointer-events: auto;
            transform: translateY(100px); opacity: 0;
            transition: all 0.6s cubic-bezier(0.2, 1, 0.3, 1);
            box-shadow: var(--shadow);
        }
        .panel.active { transform: translateY(0); opacity: 1; }

        /* Left Side: Forecast & Chart */
        .left-col { display: flex; flex-direction: column; gap: 15px; width: 350px; }
        
        .forecast-row {
            display: flex; gap: 10px; overflow-x: auto; padding-bottom: 5px;
            scrollbar-width: none; /* Firefox */
        }
        .forecast-row::-webkit-scrollbar { display: none; }
        
        .day-card {
            background: rgba(255,255,255,0.05); border-radius: 12px;
            padding: 8px; text-align: center; min-width: 60px;
            display: flex; flex-direction: column; gap: 4px;
        }
        .day-name { font-size: 0.7rem; color: #aaa; }
        .day-icon { font-size: 1.2rem; }
        .day-temp { font-size: 0.8rem; font-weight: bold; font-family: 'Exo 2'; }

        /* Right Side: Main Weather */
        .weather-main { flex: 1; max-width: 450px; position: relative; overflow: hidden; }
        .weather-main::after {
            content: ''; position: absolute; top:0; left:0; width: 100%; height: 4px;
            background: linear-gradient(90deg, var(--blue), var(--purple));
        }

        .location-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px; }
        .city-name { font-size: 1.8rem; font-weight: 800; line-height: 1.2; }
        .coords-text { font-size: 0.7rem; color: #666; font-family: 'Exo 2'; margin-top: 5px; }
        .date-time { font-size: 0.85rem; color: #bbb; background: rgba(255,255,255,0.08); padding: 4px 10px; border-radius: 12px; }

        .big-weather { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
        .temp-box { text-align: right; }
        .temp-huge { font-family: 'Exo 2'; font-size: 4.5rem; font-weight: 700; line-height: 1; letter-spacing: -2px; }
        .weather-desc { font-size: 1.1rem; color: var(--blue); font-weight: 500; }
        .icon-huge { font-size: 4rem; filter: drop-shadow(0 0 15px rgba(255,255,255,0.3)); }

        .grid-details { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .detail-item { background: rgba(255,255,255,0.03); padding: 10px 5px; border-radius: 12px; text-align: center; border: 1px solid rgba(255,255,255,0.05); }
        .detail-label { display: block; font-size: 0.65rem; color: #888; margin-bottom: 2px; }
        .detail-val { font-size: 0.95rem; font-weight: 700; font-family: 'Exo 2'; }

        /* Toast Notification */
        .toast-container {
            position: fixed; top: 90px; right: 20px; z-index: 100;
            display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }
        .toast {
            background: rgba(20, 20, 30, 0.95); border-right: 4px solid var(--blue);
            color: #fff; padding: 12px 20px; border-radius: 8px; min-width: 250px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); transform: translateX(120%); transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-size: 0.9rem; pointer-events: auto; display: flex; align-items: center; gap: 10px;
        }
        .toast.show { transform: translateX(0); }
        .toast.error { border-color: #ff4444; }

        /* Loader */
        .loader { position: fixed; inset: 0; background: #020202; z-index: 999; display: flex; justify-content: center; align-items: center; transition: opacity 0.8s; }
        .loader-ring { width: 50px; height: 50px; border: 3px solid rgba(255,255,255,0.1); border-top-color: var(--blue); border-radius: 50%; animation: spin 0.8s infinite linear; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Responsive */
        @media (max-width: 800px) {
            .dashboard { flex-direction: column-reverse; align-items: stretch; }
            .left-col { width: 100%; display: none; }
            .weather-main { max-width: 100%; }
            .temp-huge { font-size: 3.5rem; }
            .search-dock { width: 100%; }
            input { width: 100%; }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>

    <div class="loader" id="loader">
        <div class="loader-ring"></div>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <div class="search-dock">
                <button class="btn-icon" onclick="searchCity()">ğŸ”</button>
                <input type="text" id="cityInput" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø£Ùˆ Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¶..." onkeypress="if(event.key==='Enter') searchCity()">
                <button class="btn-icon" id="micBtn" onclick="startVoice()">ğŸ¤</button>
                <button class="btn-icon" onclick="locateUser()" title="Ù…ÙˆÙ‚Ø¹ÙŠ (GPS/IP)">ğŸ“</button>
            </div>
            <div class="brand">EARTH <span style="font-weight:300; font-size: 1rem; color:var(--blue)">PRO v3</span></div>
        </header>

        <div class="dashboard">
            <div class="panel left-col active">
                <div style="font-size:0.9rem; font-weight:700; margin-bottom:5px;">ØªÙˆÙ‚Ø¹Ø§Øª 5 Ø£ÙŠØ§Ù…</div>
                <div class="forecast-row" id="forecastRow">
                    <div class="day-card"><div class="day-name">--</div><div class="day-icon">-</div><div class="day-temp">--</div></div>
                </div>
                
                <div style="height: 120px; margin-top:10px;">
                    <canvas id="weatherChart"></canvas>
                </div>
            </div>

            <div class="panel weather-main" id="weatherPanel">
                <div class="location-header">
                    <div>
                        <div class="date-time" id="localTime">--:--</div>
                        <div class="coords-text" id="coordsDisplay">LAT: -- LON: --</div>
                    </div>
                    <div class="city-name" id="uiCity">Ø§Ø®ØªØ± Ù…ÙˆÙ‚Ø¹Ø§Ù‹</div>
                </div>

                <div class="big-weather">
                    <div class="icon-huge" id="wIcon">ğŸŒ</div>
                    <div class="temp-box">
                        <div class="temp-huge" id="uiTemp">--Â°</div>
                        <div class="weather-desc" id="uiDesc">Ù†Ø¸Ø§Ù… ØªÙØ§Ø¹Ù„ÙŠ</div>
                    </div>
                </div>

                <div class="grid-details">
                    <div class="detail-item"><span class="detail-label">Ø§Ù„Ø±ÙŠØ§Ø­</span><span class="detail-val" id="uiWind">--</span></div>
                    <div class="detail-item"><span class="detail-label">Ø§Ù„Ø±Ø·ÙˆØ¨Ø©</span><span class="detail-val" id="uiHum">--</span></div>
                    <div class="detail-item"><span class="detail-label">Ø§Ù„Ø¶ØºØ·</span><span class="detail-val" id="uiPress">--</span></div>
                    <div class="detail-item"><span class="detail-label">Ø§Ù„Ø±Ø¤ÙŠØ©</span><span class="detail-val" id="uiVis">--</span></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // --- GLOBAL VARIABLES ---
        let pin = null;
        let chartInstance = null;
        let isFetching = false;

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 16;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 6;
        controls.maxDistance = 40;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;

        // --- 2. EARTH OBJECTS & SHADERS (IMPROVED) ---
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);

        const texLoader = new THREE.TextureLoader();

        // Earth Surface (Standard Phong with Specular/Normal maps)
        const earthGeo = new THREE.SphereGeometry(5, 64, 64);
        const earthMat = new THREE.MeshPhongMaterial({
            map: texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg'),
            specularMap: texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg'),
            normalMap: texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg'),
            shininess: 15
        });
        const earth = new THREE.Mesh(earthGeo, earthMat);
        earthGroup.add(earth);

        // Clouds (Rotating Layer)
        const cloudMat = new THREE.MeshPhongMaterial({
            map: texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png'),
            transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
        });
        const clouds = new THREE.Mesh(new THREE.SphereGeometry(5.08, 64, 64), cloudMat);
        earthGroup.add(clouds);

        // Atmosphere Halo (ULTRA REALISTIC SHADER)
        // This creates the glowing rim effect
        const atmosMat = new THREE.ShaderMaterial({
            uniforms: { 
                c: { value: 0.6 }, 
                p: { value: 4.0 }, 
                glowColor: { value: new THREE.Color(0x4facfe) }, 
                viewVector: { value: camera.position } 
            },
            vertexShader: `
                uniform vec3 viewVector;
                varying float intensity;
                void main() {
                    vec3 vNormal = normalize(normalMatrix * normal);
                    vec3 vNormel = normalize(normalMatrix * viewVector);
                    intensity = pow(c - dot(vNormal, vNormel), p);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                varying float intensity;
                void main() {
                    vec3 glow = glowColor * intensity;
                    gl_FragColor = vec4(glow, 1.0);
                }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        const atmosphere = new THREE.Mesh(new THREE.SphereGeometry(5.35, 64, 64), atmosMat);
        scene.add(atmosphere);

        // Stars (Background)
        const starGeo = new THREE.BufferGeometry();
        const starCount = 3500;
        const posArray = new Float32Array(starCount * 3);
        const sizeArray = new Float32Array(starCount);
        for(let i=0; i<starCount; i++) {
            posArray[i*3] = (Math.random()-0.5) * 800;
            posArray[i*3+1] = (Math.random()-0.5) * 800;
            posArray[i*3+2] = (Math.random()-0.5) * 800;
            sizeArray[i] = Math.random();
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        starGeo.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.3, transparent: true, opacity: 0.8});
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // Lights
        const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
        sunLight.position.set(20, 10, 20);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.4));

        // --- 3. INTERACTION (RAYCASTER) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let startPos = {x:0, y:0};

        const canvas = document.getElementById('canvas-container');
        
        canvas.addEventListener('mousedown', (e) => { isDragging = false; startPos = {x: e.clientX, y: e.clientY}; });
        canvas.addEventListener('mousemove', (e) => { if(Math.abs(e.clientX - startPos.x) > 5) isDragging = true; });
        canvas.addEventListener('mouseup', (e) => { if(!isDragging) onGlobeClick(e); });
        canvas.addEventListener('touchstart', (e) => { isDragging = false; startPos = {x: e.touches[0].clientX, y: e.touches[0].clientY}; }, {passive: false});

        function onGlobeClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(earth);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                // Inverse the group rotation to find static local point
                const localPoint = point.clone().applyMatrix4(earthGroup.matrixWorld.invert());
                const localSpherical = new THREE.Spherical().setFromVector3(localPoint);

                let lat = 90 - (localSpherical.phi * 180 / Math.PI);
                let lon = (localSpherical.theta * 180 / Math.PI); 

                showToast("Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø·Ù‚Ø³ Ù„Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª...", "info");
                searchByCoords(lat, lon, true);
            }
        }


        // --- 4. WEATHER LOGIC & SMART LOCATION ---
        
        // ** Improved Location Logic: GPS with IP Fallback **
        window.locateUser = () => {
            showToast("Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹...", "info");
            
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        searchByCoords(pos.coords.latitude, pos.coords.longitude);
                    },
                    (err) => {
                        console.warn("GPS failed/denied. Falling back to IP...");
                        fetchIPLocation();
                    },
                    { timeout: 5000 } // Wait 5s for GPS, then fallback
                );
            } else {
                fetchIPLocation();
            }
        };

        // Fallback function for IP Location
        async function fetchIPLocation() {
            try {
                const res = await fetch('https://ipapi.co/json/').then(r => r.json());
                showToast(`ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø¹Ø¨Ø± Ø§Ù„Ø´Ø¨ÙƒØ©: ${res.city}`);
                searchByCoords(res.latitude, res.longitude);
            } catch(e) {
                showToast("ØªØ¹Ø°Ø± ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹", "error");
            }
        }

        window.searchCity = async () => {
            const city = document.getElementById('cityInput').value;
            if(!city) return;
            
            try {
                showToast(`Ø¨Ø­Ø« Ø¹Ù†: ${city}`, "info");
                const geo = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${city}&count=1&language=ar&format=json`).then(r=>r.json());
                if(!geo.results) throw new Error("Not Found");
                searchByCoords(geo.results[0].latitude, geo.results[0].longitude);
            } catch(e) { 
                showToast("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©", "error"); 
            }
        };

        async function searchByCoords(lat, lon, isClick = false) {
            if(isFetching) return;
            isFetching = true;

            controls.autoRotate = false;
            setTimeout(() => controls.autoRotate = true, 15000); // Pause rotation longer to view

            // Animation
            flyTo(lat, lon);
            addPulsePin(lat, lon);

            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m,surface_pressure,visibility,is_day&hourly=temperature_2m&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=auto`;
            
            try {
                const res = await fetch(url).then(r=>r.json());
                updateUI(res, lat, lon, isClick);
            } catch(e) {
                showToast("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„", "error");
            }
            isFetching = false;
        }

        function updateUI(data, lat, lon, isClick) {
            const cur = data.current;
            
            document.querySelectorAll('.panel').forEach(p => p.classList.add('active'));

            const cityDisplay = isClick ? `Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù…Ø­Ø¯Ø¯Ø©` : data.timezone.split('/')[1].replace(/_/g, ' ');
            document.getElementById('uiCity').innerText = cityDisplay;
            document.getElementById('coordsDisplay').innerText = `${lat.toFixed(2)}, ${lon.toFixed(2)}`;
            document.getElementById('localTime').innerText = new Date().toLocaleTimeString('en-US', { timeZone: data.timezone, hour:'2-digit', minute:'2-digit' });
            
            document.getElementById('uiTemp').innerText = Math.round(cur.temperature_2m) + "Â°";
            document.getElementById('uiDesc').innerText = getWeatherText(cur.weather_code);
            document.getElementById('wIcon').innerText = getWeatherIcon(cur.weather_code, cur.is_day);

            // Stats
            document.getElementById('uiWind').innerText = cur.wind_speed_10m + " km/h";
            document.getElementById('uiHum').innerText = cur.relative_humidity_2m + "%";
            document.getElementById('uiPress').innerText = cur.surface_pressure + " hPa";
            document.getElementById('uiVis').innerText = (cur.visibility/1000).toFixed(1) + " km";

            // Chart & Forecast
            updateChart(data.hourly);
            updateForecast(data.daily);

            // Lighting based on local time of location
            if(cur.is_day === 1) {
                sunLight.intensity = 2.5;
                atmosphere.material.uniforms.glowColor.value.setHex(0x4facfe);
            } else {
                sunLight.intensity = 0.2;
                atmosphere.material.uniforms.glowColor.value.setHex(0x2a0a5e); // Deep purple night glow
            }
        }

        function updateForecast(daily) {
            const container = document.getElementById('forecastRow');
            container.innerHTML = '';
            
            for(let i=0; i<5; i++) {
                const date = new Date(daily.time[i]);
                const dayName = date.toLocaleDateString('ar-EG', {weekday: 'short'});
                const icon = getWeatherIcon(daily.weather_code[i], 1);
                const max = Math.round(daily.temperature_2m_max[i]);
                const min = Math.round(daily.temperature_2m_min[i]);

                const div = document.createElement('div');
                div.className = 'day-card';
                div.innerHTML = `
                    <div class="day-name">${dayName}</div>
                    <div class="day-icon">${icon}</div>
                    <div class="day-temp">${max}Â° <span style="font-size:0.7em;color:#888">${min}Â°</span></div>
                `;
                container.appendChild(div);
            }
        }

        // --- 5. VOICE SEARCH ---
        window.startVoice = () => {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if(!SpeechRecognition) {
                showToast("Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØµÙˆØªÙŠØ©", "error");
                return;
            }

            const rec = new SpeechRecognition();
            rec.lang = 'ar-SA';
            rec.start();
            
            const btn = document.getElementById('micBtn');
            btn.classList.add('recording');
            showToast("ØªØ­Ø¯Ø« Ø§Ù„Ø¢Ù†...", "info");

            rec.onresult = (e) => {
                const txt = e.results[0][0].transcript.replace('.', '');
                document.getElementById('cityInput').value = txt;
                searchCity();
                btn.classList.remove('recording');
            };

            rec.onerror = () => {
                btn.classList.remove('recording');
                showToast("Ù„Ù… Ø£ÙÙ‡Ù…ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰", "error");
            };
            
            rec.onend = () => btn.classList.remove('recording');
        };

        // --- 6. VISUAL HELPERS ---

        function flyTo(lat, lon) {
            const targetX = lat * (Math.PI / 180);
            const targetY = -1 * (lon * (Math.PI / 180)) - (Math.PI / 2);

            new TWEEN.Tween(earthGroup.rotation)
                .to({ x: targetX, y: targetY }, 1500)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }

        function addPulsePin(lat, lon) {
            if(pin) earthGroup.remove(pin);
            
            const r = 5.05;
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            
            const x = -(r * Math.sin(phi) * Math.cos(theta));
            const y = r * Math.cos(phi);
            const z = r * Math.sin(phi) * Math.sin(theta);

            pin = new THREE.Group();
            
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.02, 0.5, 8),
                new THREE.MeshBasicMaterial({color: 0xffffff})
            );
            stem.rotation.x = Math.PI/2;
            stem.position.z = 0.25;
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                new THREE.MeshBasicMaterial({color: 0xff0055})
            );
            head.position.z = 0.5;

            const ringGeo = new THREE.RingGeometry(0.1, 0.15, 32);
            const ringMat = new THREE.MeshBasicMaterial({color: 0xff0055, side: THREE.DoubleSide, transparent:true});
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.z = 0.02;
            ring.lookAt(0,0,0);

            pin.add(stem); pin.add(head); pin.add(ring);
            pin.position.set(x, y, z);
            pin.lookAt(0,0,0);
            earthGroup.add(pin);

            // Continuous Pulse
            new TWEEN.Tween(ring.scale).to({x: 5, y: 5}, 1500).repeat(Infinity).start();
            new TWEEN.Tween(ring.material).to({opacity: 0}, 1500).repeat(Infinity).start();
        }

        function updateChart(hourly) {
            const ctx = document.getElementById('weatherChart').getContext('2d');
            if(chartInstance) chartInstance.destroy();
            
            const gradient = ctx.createLinearGradient(0,0,0,150);
            gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
            gradient.addColorStop(1, 'rgba(79, 172, 254, 0)');

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: hourly.time.slice(0, 12).map(t => t.slice(11, 16)),
                    datasets: [{
                        data: hourly.temperature_2m.slice(0, 12),
                        borderColor: '#4facfe',
                        backgroundColor: gradient,
                        fill: true, tension: 0.4, borderWidth: 2, pointRadius: 3, pointBackgroundColor: '#fff'
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: { 
                        x: { display: true, ticks: {color: 'rgba(255,255,255,0.3)', font:{size:9}}, grid: {display:false} }, 
                        y: { display: false } 
                    }
                }
            });
        }

        // --- UTILS ---
        function getWeatherText(code) {
            const map = { 0:"Ø³Ù…Ø§Ø¡ ØµØ§ÙÙŠØ©", 1:"ØºØ§Ø¦Ù… Ø¬Ø²Ø¦ÙŠØ§Ù‹", 2:"ØºØ§Ø¦Ù…", 3:"Ù…Ù„Ø¨Ø¯ Ø¨Ø§Ù„ØºÙŠÙˆÙ…", 45:"Ø¶Ø¨Ø§Ø¨", 48:"Ø¶Ø¨Ø§Ø¨ Ø¬Ù„ÙŠØ¯ÙŠ", 51:"Ø±Ø°Ø§Ø° Ø®ÙÙŠÙ", 53:"Ø±Ø°Ø§Ø° Ù…ØªÙˆØ³Ø·", 55:"Ø±Ø°Ø§Ø° ÙƒØ«ÙŠÙ", 61:"Ù…Ø·Ø± Ø®ÙÙŠÙ", 63:"Ù…Ø·Ø± Ù…ØªÙˆØ³Ø·", 65:"Ù…Ø·Ø± ØºØ²ÙŠØ±", 71:"Ø«Ù„ÙˆØ¬ Ø®ÙÙŠÙØ©", 73:"Ø«Ù„ÙˆØ¬ Ù…ØªÙˆØ³Ø·Ø©", 75:"Ø«Ù„ÙˆØ¬ ÙƒØ«ÙŠÙØ©", 95:"Ø¹Ø§ØµÙØ© Ø±Ø¹Ø¯ÙŠØ©" };
            return map[code] || "Ù…ØªÙ‚Ù„Ø¨";
        }

        function getWeatherIcon(code, isDay) {
            if(code === 0) return isDay ? "â˜€ï¸" : "ğŸŒ™";
            if(code <= 3) return "â˜ï¸";
            if(code <= 50) return "ğŸŒ«ï¸";
            if(code <= 67) return "ğŸŒ§ï¸";
            if(code <= 77) return "â„ï¸";
            return "âš¡";
        }

        function showToast(msg, type='info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerText = msg;
            container.appendChild(toast);
            requestAnimationFrame(() => toast.classList.add('show'));
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 500);
            }, 3000);
        }

        // --- ANIMATION LOOP ---
        function animate(t) {
            requestAnimationFrame(animate);
            TWEEN.update(t);
            controls.update();
            clouds.rotation.y += 0.0003; 
            
            if(Math.random() > 0.9) stars.material.opacity = 0.5 + Math.random() * 0.5;

            // Shader update for atmosphere glow direction
            atmosphere.material.uniforms.viewVector.value = new THREE.Vector3().subVectors(camera.position, atmosphere.position);
            
            renderer.render(scene, camera);
        }
        animate();

        // Initial Load
        window.onload = () => {
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 800);
            }, 1000);
        };
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
