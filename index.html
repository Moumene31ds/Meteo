<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EARTH SUPREME | Cast Ultimate</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåç</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;500;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>

    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-purple: #bc13fe;
            --glass-bg: rgba(8, 12, 24, 0.85);
            --border: rgba(255, 255, 255, 0.1);
            --danger: #ff2a2a;
            --safe: #00ff88;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Cairo', sans-serif; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body { 
            background: #000; overflow: hidden; height: 100vh; color: white; user-select: none; transition: background 1s;
        }

        /* Cinematic Overlays */
        #fx-layer { position: absolute; inset: 0; pointer-events: none; z-index: 5; opacity: 0.6; mix-blend-mode: screen; transition: opacity 1s; }
        .rain { background: url('https://i.imgur.com/VuT2g8X.png'); animation: rain 0.4s linear infinite; }
        .snow { background: url('https://i.imgur.com/8R0TjqV.png'); animation: snow 8s linear infinite; }
        @keyframes rain { 0% { background-position: 0 0; } 100% { background-position: 10% 100%; } }
        @keyframes snow { 0% { background-position: 0 0; } 100% { background-position: 100% 100%; } }

        /* Canvas */
        #canvas-container { position: absolute; inset: 0; z-index: 1; cursor: grab; background: #000; }
        #canvas-container:active { cursor: grabbing; }

        /* UI Layer */
        #ui-layer { position: absolute; inset: 0; z-index: 10; pointer-events: none; display: flex; flex-direction: column; padding: 20px; transition: all 0.5s; }

        /* Header */
        header { display: flex; justify-content: space-between; align-items: center; pointer-events: auto; width: 100%; z-index: 20; transition: transform 0.5s; }
        .brand { 
            font-family: 'Rajdhani', sans-serif; font-size: 1.8rem; font-weight: 700; letter-spacing: 2px;
            background: linear-gradient(90deg, #fff, var(--neon-blue)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
        }

        .search-dock {
            background: rgba(0,0,0,0.6); backdrop-filter: blur(15px); border: 1px solid var(--border);
            border-radius: 50px; padding: 5px 8px; display: flex; align-items: center; gap: 5px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); transition: 0.3s;
        }
        .search-dock:focus-within { border-color: var(--neon-blue); box-shadow: 0 0 20px rgba(0, 243, 255, 0.3); }

        input { background: transparent; border: none; color: white; width: 180px; font-size: 1rem; text-align: right; padding: 5px; font-weight: 500; }
        input::placeholder { color: rgba(255,255,255,0.4); }
        
        .btn-icon { 
            background: rgba(255,255,255,0.05); border: 1px solid transparent; color: white; cursor: pointer; 
            width:40px; height:40px; border-radius: 50%; transition: 0.2s; display:flex; align-items:center; justify-content:center; font-size: 1.1rem; 
        }
        .btn-icon:hover { background: rgba(255,255,255,0.15); color: var(--neon-blue); transform: scale(1.05); }
        .btn-icon.active { background: var(--neon-blue); color: #000; box-shadow: 0 0 15px var(--neon-blue); }
        .recording { color: var(--danger); border-color: var(--danger); animation: pulse 1.5s infinite; }
        
        /* Cast Specific Styles */
        .cast-connected { 
            color: var(--safe) !important; 
            border-color: var(--safe) !important;
            box-shadow: 0 0 20px var(--safe);
        }
        
        /* New Remote Control Panel for Cast */
        .cast-remote {
            position: fixed; top: 80px; right: 20px;
            background: rgba(0,0,0,0.8); border: 1px solid var(--safe);
            border-radius: 15px; padding: 10px;
            display: flex; flex-direction: column; gap: 10px;
            transform: translateX(200%); transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto; z-index: 50;
        }
        .cast-remote.show { transform: translateX(0); }
        .cast-status-text { font-size: 0.7rem; color: var(--safe); text-align: center; margin-bottom: 5px; font-family: 'Rajdhani'; }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 42, 42, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(255, 42, 42, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 42, 42, 0); } }

        /* Controls Side Bar */
        .controls { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 12px; pointer-events: auto; transition: transform 0.5s; }

        /* Dashboard */
        .dashboard { margin-top: auto; display: flex; gap: 20px; align-items: flex-end; width: 100%; pointer-events: none; transition: all 0.5s; }
        
        .panel {
            background: var(--glass-bg); backdrop-filter: blur(25px); border: 1px solid var(--border);
            border-radius: 20px; padding: 20px; pointer-events: auto;
            transform: translateY(120px); opacity: 0; transition: all 0.7s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
        }
        .panel.active { transform: translateY(0); opacity: 1; }

        /* Left Col */
        .left-col { width: 340px; display: flex; flex-direction: column; gap: 10px; }
        .chart-header { display: flex; justify-content: space-between; font-size: 0.8rem; color: #888; font-family: 'Rajdhani'; letter-spacing: 1px; }
        .forecast-row { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 5px; scrollbar-width: none; }
        .forecast-row::-webkit-scrollbar { display: none; }
        .day-card { background: rgba(255,255,255,0.03); border-radius: 12px; padding: 10px 5px; text-align: center; min-width: 60px; border: 1px solid rgba(255,255,255,0.02); }
        .day-temp { font-family: 'Rajdhani'; font-weight: 700; margin-top: 5px; color: var(--neon-blue); }

        /* Main Weather Card */
        .weather-main { flex: 1; max-width: 500px; position: relative; overflow: hidden; transition: all 0.8s ease-in-out; }
        .weather-main::before { content: ''; position: absolute; top:0; left:0; width:4px; height:100%; background: linear-gradient(180deg, var(--neon-blue), var(--neon-purple)); }
        
        .city-header { display: flex; justify-content: space-between; align-items: flex-start; }
        .city-name { font-size: 2rem; font-weight: 900; line-height: 1.1; margin-bottom: 5px; transition: font-size 0.5s; }
        .city-meta { font-family: 'Rajdhani'; color: #888; font-size: 0.8rem; letter-spacing: 1px; display: flex; gap: 10px; }
        
        .weather-flex { display: flex; align-items: center; justify-content: space-between; margin: 20px 0; }
        .temp-huge { font-family: 'Rajdhani'; font-size: 4.5rem; font-weight: 700; line-height: 0.9; transition: font-size 0.5s; }
        .desc-text { color: var(--neon-blue); font-size: 1.1rem; margin-top: 5px; }
        .weather-icon { font-size: 4rem; filter: drop-shadow(0 0 20px rgba(255,255,255,0.2)); transition: transform 0.5s; }

        .details-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .stat-box { background: rgba(255,255,255,0.03); padding: 10px; border-radius: 12px; text-align: center; }
        .stat-label { font-size: 0.7rem; color: #aaa; display: block; margin-bottom: 3px; }
        .stat-val { font-family: 'Rajdhani'; font-weight: 700; font-size: 1rem; }

        /* Loader */
        .loader { position: fixed; inset: 0; background: #000; z-index: 1000; display: flex; justify-content: center; align-items: center; transition: opacity 1s; }
        .scan-line { width: 200px; height: 2px; background: var(--neon-blue); animation: scan 2s infinite ease-in-out; box-shadow: 0 0 20px var(--neon-blue); }
        @keyframes scan { 0% { width:0; opacity:0; } 50% { width:200px; opacity:1; } 100% { width:0; opacity:0; } }

        /* Responsive */
        @media (max-width: 800px) {
            .dashboard { flex-direction: column-reverse; }
            .left-col { display: none; }
            .weather-main { width: 100%; max-width: 100%; }
            .search-dock { width: 100%; }
            input { width: 100%; }
            .controls { top: auto; bottom: 380px; right: 20px; flex-direction: row; }
            .cast-remote { top: auto; bottom: 100px; right: 20px; }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>

    <div class="loader" id="loader">
        <div style="text-align: center;">
            <div class="scan-line"></div>
            <div style="margin-top: 20px; font-family: 'Rajdhani'; letter-spacing: 5px; color: #888; font-size: 0.8rem;">SYSTEM LOADING</div>
        </div>
    </div>

    <div class="cast-remote" id="castRemote">
        <div class="cast-status-text">TV CONNECTED</div>
        <button class="btn-icon" onclick="stopCast()" title="ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿ®ÿ´" style="color: var(--danger); border-color: var(--danger)">‚èπ</button>
        <button class="btn-icon" onclick="toggleMute()" title="ŸÉÿ™ŸÖ ÿµŸàÿ™ ÿßŸÑÿ™ŸÑŸÅÿ≤ŸäŸàŸÜ">üîá</button>
    </div>

    <div id="fx-layer"></div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <div class="search-dock">
                <button class="btn-icon" onclick="searchCity()">üîç</button>
                <input type="text" id="cityInput" placeholder="ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ŸÖÿØŸäŸÜÿ©..." onkeypress="if(event.key==='Enter') searchCity()">
                <button class="btn-icon" id="micBtn" onclick="toggleVoice()">üéôÔ∏è</button>
                <button class="btn-icon" onclick="locateUser()">üìç</button>
            </div>
            <div class="brand">EARTH <span style="color:var(--neon-blue)">SUPREME</span></div>
        </header>

        <div class="controls">
            <button class="btn-icon" id="castBtn" onclick="requestCastSession()" title="ÿ®ÿ´ ÿ•ŸÑŸâ ÿßŸÑÿ™ŸÑŸÅÿ≤ŸäŸàŸÜ">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                    <path d="M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.92-11-11-11zM21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/>
                </svg>
            </button>

            <button class="btn-icon" id="tourBtn" onclick="toggleTour()" title="ÿ¨ŸàŸÑÿ© ÿ≠ŸàŸÑ ÿßŸÑÿπÿßŸÑŸÖ">‚úàÔ∏è</button>
            <button class="btn-icon" onclick="toggleHolo()" title="ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸáŸàŸÑŸàÿ∫ÿ±ÿßŸÅŸä">üåê</button>
            <button class="btn-icon" onclick="toggleTTS()" id="ttsBtn" title="ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑÿ∑ŸÇÿ≥">üîä</button>
        </div>

        <div class="dashboard">
            <div class="panel left-col active">
                <div class="chart-header">
                    <span>HOURLY TREND</span>
                    <span style="color:var(--neon-blue)">ECMWF AI</span>
                </div>
                <div style="height: 100px; margin: 10px 0;">
                    <canvas id="weatherChart"></canvas>
                </div>
                <div class="forecast-row" id="forecastRow"></div>
            </div>

            <div class="panel weather-main" id="weatherPanel">
                <div class="city-header">
                    <div>
                        <div class="city-name" id="uiCity">Orbit View</div>
                        <div class="city-meta">
                            <span id="uiCoords">0.00, 0.00</span>
                            <span id="uiTime" style="color:var(--neon-blue)">--:--</span>
                        </div>
                    </div>
                </div>

                <div class="weather-flex">
                    <div class="weather-icon" id="uiIcon">üåç</div>
                    <div style="text-align: left;">
                        <div class="temp-huge" id="uiTemp">--¬∞</div>
                        <div class="desc-text" id="uiDesc">ÿßÿÆÿ™ÿ± ŸÖŸàŸÇÿπÿßŸã</div>
                    </div>
                </div>

                <div class="details-grid">
                    <div class="stat-box">
                        <span class="stat-label">WIND</span>
                        <span class="stat-val" id="uiWind">--</span>
                    </div>
                    <div class="stat-box">
                        <span class="stat-label">HUMIDITY</span>
                        <span class="stat-val" id="uiHum">--</span>
                    </div>
                    <div class="stat-box">
                        <span class="stat-label">UV INDEX</span>
                        <span class="stat-val" id="uiUV" style="color:var(--neon-blue)">--</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // --- GLOBAL STATE ---
        let pin = null;
        let chartInstance = null;
        let isFetching = false;
        let isTouring = false;
        let tourTimer = null;
        let ttsEnabled = false;

        // Current Weather Data storage for Cast
        let currentWeatherData = {
            city: "Orbit View",
            temp: 0,
            desc: "Waiting...",
            code: 0
        };

        // Scene Objects
        let earth, clouds, atmosphere, stars, sunLight, sunSprite;
        let realisticMat, holoMat;
        let isHolo = false;

        // --- 1. ADVANCED CAST IMPLEMENTATION ---
        let castSession = null;

        window['__onGCastApiAvailable'] = function(isAvailable) {
            if (isAvailable) {
                initializeCastApi();
            }
        };

        function initializeCastApi() {
            cast.framework.CastContext.getInstance().setOptions({
                receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
            });

            const context = cast.framework.CastContext.getInstance();
            context.addEventListener(
                cast.framework.CastContextEventType.SESSION_STATE_CHANGED,
                function(event) {
                    const btn = document.getElementById('castBtn');
                    const remote = document.getElementById('castRemote');
                    
                    switch (event.sessionState) {
                        case cast.framework.SessionState.SESSION_STARTED:
                        case cast.framework.SessionState.SESSION_RESUMED:
                            castSession = event.session;
                            btn.classList.add('cast-connected');
                            remote.classList.add('show');
                            speakText("ÿ™ŸÖ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ™ŸÑŸÅÿ≤ŸäŸàŸÜ. ÿ¨ÿßÿ±Ÿä ŸÖÿ≤ÿßŸÖŸÜÿ© ÿßŸÑÿ∑ŸÇÿ≥.");
                            // Immediately sync current weather to TV
                            syncToTV();
                            break;
                        case cast.framework.SessionState.SESSION_ENDED:
                            castSession = null;
                            btn.classList.remove('cast-connected');
                            remote.classList.remove('show');
                            speakText("ÿ™ŸÖ ŸÇÿ∑ÿπ ÿßŸÑÿßÿ™ÿµÿßŸÑ");
                            break;
                    }
                }
            );
        }

        window.requestCastSession = function() {
            if(!window.cast) return alert("Ÿäÿ±ÿ¨Ÿâ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿ™ÿµŸÅÿ≠ Chrome ÿ£Ÿà Edge");
            cast.framework.CastContext.getInstance().requestSession()
                .catch(err => console.log('Cast Error:', err));
        };

        window.stopCast = function() {
            if(castSession) {
                castSession.endSession(true);
            }
        };

        window.toggleMute = function() {
            if(!castSession) return;
            const volume = castSession.getVolume();
            volume.muted = !volume.muted;
            castSession.setVolume(volume);
        };

        // The Core Magic: Sends a "Weather Card" to the TV
        function syncToTV() {
            if (!castSession) return;

            // Define media based on weather code
            // Using reliable high-res generic images for weather states
            // You can replace these with video loops if you have direct MP4 links
            let mediaUrl = 'https://images.unsplash.com/photo-1451187580459-43490279c0fa?q=80&w=1920&auto=format&fit=crop'; // Default Space
            const code = currentWeatherData.code;
            
            // Map codes to nice images
            if (code <= 1) mediaUrl = 'https://images.unsplash.com/photo-1592210454359-9043f067919b?q=80&w=1920'; // Sunny
            else if (code <= 3) mediaUrl = 'https://images.unsplash.com/photo-1534088568595-a066f410bcda?q=80&w=1920'; // Cloudy
            else if (code <= 45) mediaUrl = 'https://images.unsplash.com/photo-1487621167305-5d248087c724?q=80&w=1920'; // Fog
            else if (code <= 67) mediaUrl = 'https://images.unsplash.com/photo-1519692933481-e162a57d6721?q=80&w=1920'; // Rain
            else if (code <= 77) mediaUrl = 'https://images.unsplash.com/photo-1478265868099-41669b5a5362?q=80&w=1920'; // Snow
            else if (code >= 95) mediaUrl = 'https://images.unsplash.com/photo-1605727216801-e27ce1d0cc28?q=80&w=1920'; // Thunder

            const mediaInfo = new chrome.cast.media.MediaInfo(mediaUrl, 'image/jpeg');
            
            // Metadata appears on TV screen
            mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
            mediaInfo.metadata.title = currentWeatherData.city; // Big Text
            mediaInfo.metadata.subtitle = `${currentWeatherData.temp}¬∞C | ${currentWeatherData.desc}`; // Small Text
            // Force image display
            mediaInfo.streamType = chrome.cast.media.StreamType.BUFFERED;

            const request = new chrome.cast.media.LoadRequest(mediaInfo);
            request.autoplay = true;

            castSession.loadMedia(request).then(
                function() { console.log('TV Updated Successfully'); },
                function(errorCode) { console.log('TV Error Code:', errorCode); }
            );
        }


        // --- 2. THREE JS SETUP (Standard) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 18;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 6.5;
        controls.maxDistance = 60;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 3. THE EARTH ---
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);
        const texLoader = new THREE.TextureLoader();
        
        const tDay = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
        const tNight = texLoader.load('https://raw.githubusercontent.com/kyleredelinghuys/three-earth/master/src/img/earth_lights_2048.png');
        const tNormal = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');
        const tSpec = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
        const tClouds = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png');

        realisticMat = new THREE.ShaderMaterial({
            uniforms: {
                sunDirection: { value: new THREE.Vector3(1, 0, 0) },
                dayTexture: { value: tDay },
                nightTexture: { value: tNight },
                normalMap: { value: tNormal },
                specularMap: { value: tSpec }
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vSunDir;
                uniform vec3 sunDirection;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vSunDir = normalize((viewMatrix * vec4(sunDirection, 0.0)).xyz);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D dayTexture;
                uniform sampler2D nightTexture;
                uniform sampler2D normalMap;
                uniform sampler2D specularMap;
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vSunDir;
                void main() {
                    vec3 dayColor = texture2D(dayTexture, vUv).rgb;
                    vec3 nightColor = texture2D(nightTexture, vUv).rgb;
                    float intensity = max(dot(vNormal, vSunDir), 0.0);
                    float mixVal = smoothstep(-0.2, 0.2, intensity);
                    vec3 finalColor = mix(nightColor, dayColor * intensity, mixVal);
                    if(intensity > 0.0) {
                        float specularFactor = texture2D(specularMap, vUv).r;
                        vec3 halfVector = normalize(vSunDir + vec3(0,0,1));
                        float NdotH = max(dot(vNormal, halfVector), 0.0);
                        float specular = pow(NdotH, 32.0) * specularFactor * intensity;
                        finalColor += vec3(0.5) * specular;
                    }
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        holoMat = new THREE.MeshBasicMaterial({
            color: 0x00f3ff, wireframe: true, transparent: true, opacity: 0.15
        });

        earth = new THREE.Mesh(new THREE.SphereGeometry(5, 64, 64), realisticMat);
        earthGroup.add(earth);

        const cloudMat = new THREE.MeshLambertMaterial({
            map: tClouds, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
        });
        clouds = new THREE.Mesh(new THREE.SphereGeometry(5.08, 64, 64), cloudMat);
        earthGroup.add(clouds);

        const atmosMat = new THREE.ShaderMaterial({
            uniforms: { c: { value: 0.6 }, p: { value: 4.5 }, glowColor: { value: new THREE.Color(0x00aaff) }, viewVector: { value: camera.position } },
            vertexShader: `
                uniform vec3 viewVector;
                varying float intensity;
                void main() {
                    vec3 vNormal = normalize(normalMatrix * normal);
                    vec3 vNormel = normalize(normalMatrix * viewVector);
                    intensity = pow(c - dot(vNormal, vNormel), p);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                varying float intensity;
                void main() { gl_FragColor = vec4(glowColor, intensity); }
            `,
            side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
        });
        atmosphere = new THREE.Mesh(new THREE.SphereGeometry(5.4, 64, 64), atmosMat);
        scene.add(atmosphere);

        const starGeo = new THREE.BufferGeometry();
        const starCount = 6000;
        const posArray = new Float32Array(starCount * 3);
        const colArray = new Float32Array(starCount * 3);
        for(let i=0; i<starCount; i++) {
            posArray[i*3] = (Math.random()-0.5) * 1500;
            posArray[i*3+1] = (Math.random()-0.5) * 1500;
            posArray[i*3+2] = (Math.random()-0.5) * 1500;
            const c = new THREE.Color();
            c.setHSL(Math.random() * 0.2 + 0.5, 0.8, Math.random() * 0.5 + 0.5);
            colArray[i*3] = c.r; colArray[i*3+1] = c.g; colArray[i*3+2] = c.b;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(colArray, 3));
        stars = new THREE.Points(starGeo, new THREE.PointsMaterial({vertexColors: true, size: 0.7, transparent: true, opacity: 0.8}));
        scene.add(stars);

        const sunGroup = new THREE.Group();
        scene.add(sunGroup);
        sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(20, 0, 0);
        sunGroup.add(sunLight);

        // Sun Sprite
        const canvasSprite = document.createElement('canvas');
        canvasSprite.width = 128; canvasSprite.height = 128;
        const ctxS = canvasSprite.getContext('2d');
        const grad = ctxS.createRadialGradient(64,64,0,64,64,64);
        grad.addColorStop(0, 'rgba(255, 255, 200, 1)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctxS.fillStyle = grad; ctxS.fillRect(0,0,128,128);
        const texSun = new THREE.CanvasTexture(canvasSprite);
        sunSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texSun, blending: THREE.AdditiveBlending }));
        sunSprite.scale.set(10, 10, 1);
        sunSprite.position.set(22, 0, 0);
        sunGroup.add(sunSprite);

        function updateSun() {
            const now = new Date();
            const utc = now.getUTCHours() + now.getUTCMinutes()/60;
            const angle = -((utc - 12) / 24) * Math.PI * 2;
            sunGroup.rotation.y = angle;
            const sunDir = new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0, angle, 0));
            if(!isHolo) realisticMat.uniforms.sunDirection.value.copy(sunDir);
        }
        setInterval(updateSun, 60000); updateSun();

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false, startPos = {x:0,y:0};
        
        renderer.domElement.addEventListener('mousedown', (e)=>{ isDragging=false; startPos={x:e.clientX,y:e.clientY}; if(!isTouring) controls.autoRotate=false; });
        renderer.domElement.addEventListener('mousemove', (e)=>{ if(Math.abs(e.clientX-startPos.x)>5) isDragging=true; });
        renderer.domElement.addEventListener('mouseup', (e)=>{ if(!isDragging) handleClick(e); if(!isTouring && !isFetching) setTimeout(()=>controls.autoRotate=true, 5000); });
        renderer.domElement.addEventListener('touchstart', (e)=>{ isDragging=false; startPos={x:e.touches[0].clientX,y:e.touches[0].clientY}; controls.autoRotate=false; }, {passive:false});

        function handleClick(e) {
            if(isTouring) stopTour();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(earth);
            if(intersects.length > 0) {
                const point = intersects[0].point;
                const local = point.clone().applyMatrix4(earthGroup.matrixWorld.invert());
                const spherical = new THREE.Spherical().setFromVector3(local);
                const lat = 90 - (spherical.phi * 180 / Math.PI);
                let lon = ((spherical.theta * 180 / Math.PI) - 90);
                if(lon < -180) lon += 360; if(lon > 180) lon -= 360;
                fetchLocationName(lat, lon);
                searchByCoords(lat, lon, true);
            }
        }

        async function fetchLocationName(lat, lon) {
            try {
                const res = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=ar`);
                const data = await res.json();
                let name = data.city || data.locality || data.principalSubdivision || data.countryName || "ŸÖŸÜÿ∑ŸÇÿ© ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅÿ©";
                if(data.countryName && name !== data.countryName) name += `ÿå ${data.countryName}`;
                document.getElementById('uiCity').innerText = name;
                document.getElementById('cityInput').value = name;
                return name;
            } catch(e) { 
                document.getElementById('uiCity').innerText = `Lat:${lat.toFixed(2)}`; 
                return "ŸÖŸàŸÇÿπ ŸÖÿ≠ÿØÿØ";
            }
        }

        window.searchCity = async () => {
            const q = document.getElementById('cityInput').value;
            if(!q) return;
            if(isTouring) stopTour();
            try {
                const res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${q}&count=1&language=ar&format=json`).then(r=>r.json());
                if(!res.results) return alert("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿØŸäŸÜÿ©");
                const loc = res.results[0];
                document.getElementById('uiCity').innerText = loc.name;
                searchByCoords(loc.latitude, loc.longitude);
            } catch(e) { alert("ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ´"); }
        };

        async function searchByCoords(lat, lon, isClick=false) {
            if(isFetching) return;
            isFetching = true;
            flyTo(lat, lon);
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m,visibility,is_day&hourly=temperature_2m&daily=weather_code,temperature_2m_max,temperature_2m_min,uv_index_max&timezone=auto&models=ecmwf_ifs04`;
            try {
                const data = await fetch(url).then(r=>r.json());
                updateUI(data, lat, lon);
            } catch(e) { console.error(e); }
            isFetching = false;
        }

        function updateUI(data, lat, lon) {
            const cur = data.current;
            const daily = data.daily;
            
            // --- Update Data Store ---
            const weatherDesc = getWeatherText(cur.weather_code);
            const cityName = document.getElementById('uiCity').innerText;
            const temp = Math.round(cur.temperature_2m);
            
            currentWeatherData = {
                city: cityName,
                temp: temp,
                desc: weatherDesc,
                code: cur.weather_code
            };

            // --- Update DOM ---
            document.querySelectorAll('.panel').forEach(p => p.classList.add('active'));
            document.getElementById('uiCoords').innerText = `${lat.toFixed(2)}, ${lon.toFixed(2)}`;
            document.getElementById('uiTime').innerText = new Date().toLocaleTimeString('en-US', {timeZone: data.timezone, hour:'2-digit', minute:'2-digit', hour12:false});
            document.getElementById('uiTemp').innerText = temp + "¬∞";
            document.getElementById('uiDesc').innerText = weatherDesc;
            document.getElementById('uiIcon').innerText = getWeatherIcon(cur.weather_code, cur.is_day);
            document.getElementById('uiWind').innerText = cur.wind_speed_10m + " km/h";
            document.getElementById('uiHum').innerText = cur.relative_humidity_2m + "%";
            document.getElementById('uiUV').innerText = daily.uv_index_max[0].toFixed(1);
            
            // --- FX & 3D ---
            addSmartPin(lat, lon, cur.temperature_2m);
            const fx = document.getElementById('fx-layer');
            fx.className = ''; fx.style.opacity = 0;
            if([51,53,55,61,63,65,80,81,82,95].includes(cur.weather_code)) { fx.className = 'rain'; fx.style.opacity = 0.6; }
            if([71,73,75,85,86].includes(cur.weather_code)) { fx.className = 'snow'; fx.style.opacity = 0.6; }
            
            updateChart(data.hourly);
            updateForecast(daily);
            
            if(ttsEnabled) speakText(`ÿßŸÑÿ∑ŸÇÿ≥ ŸÅŸä ${cityName}. ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ© ${temp}.`);

            // --- TRIGGER TV UPDATE IF CONNECTED ---
            if(castSession) {
                syncToTV();
            }
        }

        function addSmartPin(lat, lon, temp) {
            if(pin) earthGroup.remove(pin);
            pin = new THREE.Group();
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 90) * (Math.PI / 180);
            const r = 5.0;
            const x = -(r * Math.sin(phi) * Math.cos(theta));
            const y = r * Math.cos(phi);
            const z = r * Math.sin(phi) * Math.sin(theta);
            pin.position.set(x,y,z);
            pin.lookAt(0,0,0);
            let color = 0x00ff88;
            if(temp > 30) color = 0xff2a2a;
            if(temp < 10) color = 0x00f3ff;
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8), new THREE.MeshBasicMaterial({color:color}));
            stem.rotation.x = Math.PI/2; stem.position.z = 0.4;
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), new THREE.MeshBasicMaterial({color:color}));
            head.position.z = 0.8;
            const ring = new THREE.Mesh(new THREE.RingGeometry(0.1, 0.15, 32), new THREE.MeshBasicMaterial({color:color, side:2, transparent:true}));
            ring.position.z = 0.05;
            pin.add(stem); pin.add(head); pin.add(ring);
            earthGroup.add(pin);
            new TWEEN.Tween(ring.scale).to({x:6,y:6}, 1500).repeat(Infinity).start();
            new TWEEN.Tween(ring.material).to({opacity:0}, 1500).repeat(Infinity).start();
        }

        const tourCities = [
            {n:"Mecca", lat:21.38, lon:39.85}, {n:"Tokyo", lat:35.67, lon:139.65},
            {n:"New York", lat:40.71, lon:-74.00}, {n:"London", lat:51.50, lon:-0.12},
            {n:"Paris", lat:48.85, lon:2.35}, {n:"Sydney", lat:-33.86, lon:151.20},
            {n:"Cairo", lat:30.04, lon:31.23}
        ];
        let tourIdx = 0;

        window.toggleTour = () => {
            isTouring = !isTouring;
            const btn = document.getElementById('tourBtn');
            if(isTouring) {
                btn.classList.add('active');
                runTourStep();
            } else {
                btn.classList.remove('active');
                clearTimeout(tourTimer);
                controls.autoRotate = true;
            }
        };

        function runTourStep() {
            if(!isTouring) return;
            const city = tourCities[tourIdx];
            document.getElementById('uiCity').innerText = city.n;
            searchByCoords(city.lat, city.lon);
            tourIdx = (tourIdx + 1) % tourCities.length;
            tourTimer = setTimeout(runTourStep, 8000);
        }

        window.toggleTTS = () => {
            ttsEnabled = !ttsEnabled;
            document.getElementById('ttsBtn').classList.toggle('active');
            if(ttsEnabled) speakText("ŸÜÿ∏ÿßŸÖ ÿßŸÑÿµŸàÿ™ ŸÖŸÅÿπŸÑ");
        };

        function speakText(text) {
            if(!window.speechSynthesis) return;
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'ar-SA';
            window.speechSynthesis.speak(u);
        }

        window.toggleHolo = () => {
            isHolo = !isHolo;
            if(isHolo) {
                earth.material = holoMat;
                clouds.visible = false;
                scene.fog = new THREE.FogExp2(0x000000, 0.005);
            } else {
                earth.material = realisticMat;
                clouds.visible = true;
                scene.fog = null;
            }
        };

        function flyTo(lat, lon) {
            const tx = lat * (Math.PI/180);
            const ty = -1 * (lon * (Math.PI/180)) - (Math.PI/2);
            new TWEEN.Tween(earthGroup.rotation).to({x:tx, y:ty}, 1500).easing(TWEEN.Easing.Cubic.InOut).start();
        }

        function updateChart(hourly) {
            const ctx = document.getElementById('weatherChart').getContext('2d');
            if(chartInstance) chartInstance.destroy();
            const gradient = ctx.createLinearGradient(0,0,0,100);
            gradient.addColorStop(0, 'rgba(0, 243, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: hourly.time.slice(0, 12).map(t => t.slice(11, 16)),
                    datasets: [{
                        data: hourly.temperature_2m.slice(0, 12),
                        borderColor: '#00f3ff', backgroundColor: gradient, fill: true, tension: 0.4, borderWidth: 2, pointRadius: 0
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: false }, scales: { x: {display:false}, y: {display:false} }
                }
            });
        }

        function updateForecast(daily) {
            const c = document.getElementById('forecastRow'); c.innerHTML='';
            for(let i=0; i<5; i++){
                const d = new Date(daily.time[i]);
                const name = d.toLocaleDateString('ar-EG', {weekday:'short'});
                const icon = getWeatherIcon(daily.weather_code[i], 1);
                const temp = Math.round(daily.temperature_2m_max[i]);
                c.innerHTML += `<div class="day-card"><div style="font-size:0.7rem; color:#aaa">${name}</div><div style="font-size:1.2rem; margin:2px 0">${icon}</div><div class="day-temp">${temp}¬∞</div></div>`;
            }
        }

        function getWeatherText(c) {
            const m = {0:"ÿ≥ŸÖÿßÿ° ÿµÿßŸÅŸäÿ©", 1:"ÿ∫ÿßÿ¶ŸÖ ÿ¨ÿ≤ÿ¶Ÿä", 3:"ÿ∫ÿßÿ¶ŸÖ", 45:"ÿ∂ÿ®ÿßÿ®", 61:"ŸÖÿ∑ÿ± ÿÆŸÅŸäŸÅ", 63:"ŸÖÿ∑ÿ±", 71:"ÿ´ŸÑŸàÿ¨", 95:"ÿπÿßÿµŸÅÿ© ÿ±ÿπÿØŸäÿ©"};
            return m[c] || "ŸÖÿ™ŸÇŸÑÿ®";
        }
        function getWeatherIcon(c,d) {
            if(c===0) return d?"‚òÄÔ∏è":"üåô"; if(c<=3) return "‚òÅÔ∏è"; if(c<=67) return "üåßÔ∏è"; if(c<=77) return "‚ùÑÔ∏è"; return "‚ö°";
        }

        function animate(t) {
            requestAnimationFrame(animate);
            TWEEN.update(t);
            controls.update();
            clouds.rotation.y += 0.0003;
            stars.rotation.y -= 0.0001;
            atmosphere.material.uniforms.viewVector.value = new THREE.Vector3().subVectors(camera.position, atmosphere.position);
            renderer.render(scene, camera);
        }
        animate();

        window.locateUser = () => { if(navigator.geolocation) navigator.geolocation.getCurrentPosition(p=>searchByCoords(p.coords.latitude, p.coords.longitude)); };
        window.toggleVoice = () => {
             const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
             if(!SR) return alert("ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ");
             const r = new SR(); r.lang='ar-SA'; r.start();
             document.getElementById('micBtn').classList.add('recording');
             r.onresult = e => { document.getElementById('cityInput').value = e.results[0][0].transcript; searchCity(); document.getElementById('micBtn').classList.remove('recording'); };
        };

        window.onload = () => { setTimeout(()=>document.getElementById('loader').style.opacity=0, 1500); setTimeout(()=>document.getElementById('loader').remove(), 2500); window.locateUser(); };
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
