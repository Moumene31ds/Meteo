<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EARTH PRO | High Precision Weather</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåç</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;500;700;900&family=Exo+2:wght@300;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        :root {
            --blue: #4facfe;
            --purple: #7028e4;
            --dark: #0a0a0a;
            --glass: rgba(15, 20, 35, 0.85);
            --border: rgba(255, 255, 255, 0.15);
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            --aqi-good: #00e400;
            --aqi-mod: #ffff00;
            --aqi-bad: #ff0000;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Cairo', sans-serif; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body { 
            background: #000; overflow: hidden; height: 100vh; color: white; user-select: none; 
            background-image: radial-gradient(circle at 50% 50%, #111 0%, #000 100%);
        }

        /* Weather Effects Overlay */
        #fx-layer { position: absolute; inset: 0; pointer-events: none; z-index: 5; opacity: 0.6; mix-blend-mode: screen; }
        .rain { background: url('https://i.imgur.com/VuT2g8X.png'); animation: rain 0.5s linear infinite; }
        .snow { background: url('https://i.imgur.com/8R0TjqV.png'); animation: snow 10s linear infinite; }
        @keyframes rain { 0% { background-position: 0 0; } 100% { background-position: 20% 100%; } }
        @keyframes snow { 0% { background-position: 0 0; } 100% { background-position: 100% 100%; } }

        /* Canvas */
        #canvas-container { position: absolute; inset: 0; z-index: 1; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }

        /* UI Layout */
        #ui-layer {
            position: absolute; inset: 0; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; padding: 20px;
        }

        /* HEADER */
        header { 
            display: flex; justify-content: space-between; align-items: center; 
            pointer-events: auto; width: 100%; z-index: 20;
        }

        .brand {
            font-family: 'Exo 2'; font-size: 1.8rem; letter-spacing: 2px; font-weight: 900;
            background: linear-gradient(90deg, #fff, var(--blue));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
        }

        .search-dock {
            background: rgba(0,0,0,0.7); backdrop-filter: blur(15px);
            border: 1px solid var(--border); border-radius: 50px;
            padding: 5px 10px; display: flex; align-items: center; gap: 8px;
            transition: 0.3s; box-shadow: var(--shadow);
        }
        .search-dock:focus-within { border-color: var(--blue); box-shadow: 0 0 25px rgba(79, 172, 254, 0.4); }

        input { background: transparent; border: none; color: white; width: 180px; font-size: 1rem; text-align: right; padding: 5px; }
        .btn-icon { background: none; border: none; color: white; cursor: pointer; padding: 10px; border-radius: 50%; transition: 0.2s; font-size: 1.1rem; }
        .btn-icon:hover { background: rgba(255,255,255,0.1); color: var(--blue); }
        .btn-icon.recording { color: #ff4444; animation: pulse-red 1.5s infinite; }

        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); } }

        /* DASHBOARD */
        .dashboard {
            margin-top: auto; display: flex; gap: 20px; align-items: flex-end;
            width: 100%; pointer-events: none;
        }

        .panel {
            background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid var(--border); border-radius: 24px;
            padding: 20px; pointer-events: auto;
            transform: translateY(100px); opacity: 0;
            transition: all 0.6s cubic-bezier(0.2, 1, 0.3, 1);
            box-shadow: var(--shadow);
        }
        .panel.active { transform: translateY(0); opacity: 1; }

        /* Left Side */
        .left-col { display: flex; flex-direction: column; gap: 15px; width: 350px; }
        .forecast-row { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 5px; scrollbar-width: none; }
        .forecast-row::-webkit-scrollbar { display: none; }
        
        .day-card {
            background: rgba(255,255,255,0.05); border-radius: 12px;
            padding: 8px; text-align: center; min-width: 60px;
            display: flex; flex-direction: column; gap: 4px;
        }
        .day-name { font-size: 0.7rem; color: #aaa; }
        .day-icon { font-size: 1.2rem; }
        .day-temp { font-size: 0.8rem; font-weight: bold; font-family: 'Exo 2'; }

        /* Right Side: Main Weather */
        .weather-main { flex: 1; max-width: 480px; position: relative; overflow: hidden; }
        .weather-main::after {
            content: ''; position: absolute; top:0; left:0; width: 100%; height: 4px;
            background: linear-gradient(90deg, var(--blue), var(--purple));
        }

        .location-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px; }
        .city-name { font-size: 1.8rem; font-weight: 800; line-height: 1.2; }
        .coords-text { font-size: 0.7rem; color: #666; font-family: 'Exo 2'; margin-top: 5px; }
        .tags-row { display: flex; gap: 5px; margin-top:5px; }
        .tag { font-size: 0.7rem; padding: 2px 8px; border-radius: 8px; background: rgba(255,255,255,0.1); }
        .aqi-tag { font-weight: bold; }

        .big-weather { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
        .temp-box { text-align: right; }
        .temp-huge { font-family: 'Exo 2'; font-size: 4.5rem; font-weight: 700; line-height: 1; letter-spacing: -2px; }
        .weather-desc { font-size: 1.1rem; color: var(--blue); font-weight: 500; }
        .icon-huge { font-size: 4rem; filter: drop-shadow(0 0 15px rgba(255,255,255,0.3)); }

        .grid-details { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
        .detail-item { background: rgba(255,255,255,0.03); padding: 10px 5px; border-radius: 12px; text-align: center; border: 1px solid rgba(255,255,255,0.05); }
        .detail-label { display: block; font-size: 0.65rem; color: #888; margin-bottom: 2px; }
        .detail-val { font-size: 0.95rem; font-weight: 700; font-family: 'Exo 2'; }

        /* Toast & Loader */
        .toast-container { position: fixed; top: 90px; right: 20px; z-index: 100; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast {
            background: rgba(20, 20, 30, 0.95); border-right: 4px solid var(--blue);
            color: #fff; padding: 12px 20px; border-radius: 8px; min-width: 250px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); transform: translateX(120%); transition: 0.4s;
            font-size: 0.9rem; pointer-events: auto; display: flex; align-items: center; gap: 10px;
        }
        .toast.show { transform: translateX(0); }
        .toast.error { border-color: #ff4444; }

        .loader { position: fixed; inset: 0; background: #000; z-index: 999; display: flex; justify-content: center; align-items: center; transition: opacity 0.8s; }
        .loader-ring { width: 60px; height: 60px; border: 3px solid rgba(255,255,255,0.1); border-top-color: var(--blue); border-radius: 50%; animation: spin 0.8s infinite linear; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Responsive */
        @media (max-width: 800px) {
            .dashboard { flex-direction: column-reverse; align-items: stretch; }
            .left-col { width: 100%; display: none; }
            .weather-main { max-width: 100%; }
            .search-dock { width: 100%; }
            input { width: 100%; }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>

    <div class="loader" id="loader">
        <div style="text-align:center">
            <div class="loader-ring"></div>
            <div style="margin-top:10px; font-family:'Exo 2'; letter-spacing:3px; font-size:0.8rem">SYSTEM INITIALIZING</div>
        </div>
    </div>

    <div id="fx-layer"></div>
    <div class="toast-container" id="toastContainer"></div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <div class="search-dock">
                <button class="btn-icon" onclick="searchCity()">üîç</button>
                <input type="text" id="cityInput" placeholder="ÿßŸÉÿ™ÿ® ÿßŸÑŸÖÿØŸäŸÜÿ© ÿ£Ÿà ÿßŸÜŸÇÿ±..." onkeypress="if(event.key==='Enter') searchCity()">
                <button class="btn-icon" id="micBtn" onclick="startVoice()">üé§</button>
                <button class="btn-icon" onclick="locateUser()" title="ŸÖŸàŸÇÿπŸä (GPS)">üìç</button>
            </div>
            <div class="brand">EARTH <span style="font-weight:300; font-size: 1rem; color:var(--blue)">PRO v5</span></div>
        </header>

        <div class="dashboard">
            <div class="panel left-col active">
                <div style="font-size:0.9rem; font-weight:700; margin-bottom:5px;">ÿ™ŸàŸÇÿπÿßÿ™ 5 ÿ£ŸäÿßŸÖ (ECMWF)</div>
                <div class="forecast-row" id="forecastRow">
                    <div class="day-card"><div class="day-name">--</div><div class="day-icon">-</div><div class="day-temp">--</div></div>
                </div>
                
                <div style="height: 120px; margin-top:10px;">
                    <canvas id="weatherChart"></canvas>
                </div>
            </div>

            <div class="panel weather-main" id="weatherPanel">
                <div class="location-header">
                    <div>
                        <div class="tags-row">
                            <span class="tag" id="localTime">--:--</span>
                            <span class="tag aqi-tag" id="aqiBadge" style="color:#aaa">AQI: --</span>
                        </div>
                        <div class="coords-text" id="coordsDisplay">LAT: -- LON: --</div>
                    </div>
                    <div class="city-name" id="uiCity">Earth View</div>
                </div>

                <div class="big-weather">
                    <div class="icon-huge" id="wIcon">üåç</div>
                    <div class="temp-box">
                        <div class="temp-huge" id="uiTemp">--¬∞</div>
                        <div class="weather-desc" id="uiDesc">ÿßÿÆÿ™ÿ± ŸÖŸàŸÇÿπÿßŸã</div>
                    </div>
                </div>

                <div class="grid-details">
                    <div class="detail-item"><span class="detail-label">ÿßŸÑÿ±Ÿäÿßÿ≠</span><span class="detail-val" id="uiWind">--</span></div>
                    <div class="detail-item"><span class="detail-label">ÿßŸÑÿ±ÿ∑Ÿàÿ®ÿ©</span><span class="detail-val" id="uiHum">--</span></div>
                    <div class="detail-item"><span class="detail-label">ÿßŸÑÿ£ÿ¥ÿπÿ© UV</span><span class="detail-val" id="uiUV">--</span></div>
                    <div class="detail-item"><span class="detail-label">ÿßŸÑÿ±ÿ§Ÿäÿ©</span><span class="detail-val" id="uiVis">--</span></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // --- GLOBAL STATE ---
        let pin = null;
        let chartInstance = null;
        let isFetching = false;
        let sunGroup;

        // --- 1. ADVANCED SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 16;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 6.5;
        controls.maxDistance = 50;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. THE EARTH (CUSTOM SHADER MATERIAL) ---
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);

        const texLoader = new THREE.TextureLoader();
        
        const mapDay = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
        const mapNight = texLoader.load('https://raw.githubusercontent.com/kyleredelinghuys/three-earth/master/src/img/earth_lights_2048.png');
        const mapNormal = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');
        const mapSpecular = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
        const mapClouds = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png');

        const earthUniforms = {
            sunDirection: { value: new THREE.Vector3(1, 0, 0) },
            dayTexture: { value: mapDay },
            nightTexture: { value: mapNight },
            normalMap: { value: mapNormal },
            specularMap: { value: mapSpecular }
        };

        const earthMat = new THREE.ShaderMaterial({
            uniforms: earthUniforms,
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vSunDir;
                uniform vec3 sunDirection;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vSunDir = normalize((viewMatrix * vec4(sunDirection, 0.0)).xyz);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D dayTexture;
                uniform sampler2D nightTexture;
                uniform sampler2D normalMap;
                uniform sampler2D specularMap;
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vSunDir;
                void main() {
                    vec3 dayColor = texture2D(dayTexture, vUv).rgb;
                    vec3 nightColor = texture2D(nightTexture, vUv).rgb;
                    vec3 normalColor = texture2D(normalMap, vUv).rgb * 2.0 - 1.0;
                    float specularFactor = texture2D(specularMap, vUv).r;
                    float intensity = max(dot(vNormal, vSunDir), 0.0);
                    float mixVal = smoothstep(-0.2, 0.2, intensity);
                    vec3 finalColor = mix(nightColor, dayColor * intensity, mixVal);
                    if(intensity > 0.0) {
                        vec3 halfVector = normalize(vSunDir + vec3(0,0,1));
                        float NdotH = max(dot(vNormal, halfVector), 0.0);
                        float specular = pow(NdotH, 32.0) * specularFactor * intensity;
                        finalColor += vec3(0.5) * specular;
                    }
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        const earthGeo = new THREE.SphereGeometry(5, 64, 64);
        const earth = new THREE.Mesh(earthGeo, earthMat);
        // Correcting Texture Rotation - standard textures are often shifted
        earthGroup.add(earth);

        // Clouds
        const cloudMat = new THREE.MeshLambertMaterial({
            map: mapClouds,
            transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        const clouds = new THREE.Mesh(new THREE.SphereGeometry(5.08, 64, 64), cloudMat);
        earthGroup.add(clouds);

        // Atmosphere Glow
        const atmosMat = new THREE.ShaderMaterial({
            uniforms: { 
                c: { value: 0.5 }, 
                p: { value: 4.5 }, 
                glowColor: { value: new THREE.Color(0x4facfe) }, 
                viewVector: { value: camera.position } 
            },
            vertexShader: `
                uniform vec3 viewVector;
                varying float intensity;
                void main() {
                    vec3 vNormal = normalize(normalMatrix * normal);
                    vec3 vNormel = normalize(normalMatrix * viewVector);
                    intensity = pow(c - dot(vNormal, vNormel), p);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                varying float intensity;
                void main() {
                    vec3 glow = glowColor * intensity;
                    gl_FragColor = vec4(glow, 1.0);
                }
            `,
            side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
        });
        const atmosphere = new THREE.Mesh(new THREE.SphereGeometry(5.4, 64, 64), atmosMat);
        scene.add(atmosphere);

        // Stars
        const starGeo = new THREE.BufferGeometry();
        const starCount = 5000;
        const posArray = new Float32Array(starCount * 3);
        for(let i=0; i<starCount; i++) {
            posArray[i*3] = (Math.random()-0.5) * 900;
            posArray[i*3+1] = (Math.random()-0.5) * 900;
            posArray[i*3+2] = (Math.random()-0.5) * 900;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.4, transparent: true, opacity: 0.8}));
        scene.add(stars);

        // --- 3. SUN LIGHT & POSITION LOGIC ---
        sunGroup = new THREE.Group();
        scene.add(sunGroup);
        const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(20, 0, 0);
        sunGroup.add(sunLight);
        
        function updateSunPosition() {
            const now = new Date();
            const utcHours = now.getUTCHours() + now.getUTCMinutes()/60;
            const sunAngle = -((utcHours - 12) / 24) * Math.PI * 2;
            sunGroup.rotation.y = sunAngle;
            const sunDir = new THREE.Vector3(1,0,0).applyEuler(new THREE.Euler(0, sunAngle, 0));
            earthMat.uniforms.sunDirection.value.copy(sunDir);
        }
        setInterval(updateSunPosition, 60000);
        updateSunPosition();

        // --- 4. INTERACTIVE HOTSPOTS ---
        const cities = [
            {n:"Mecca", lat:21.38, lon:39.85}, {n:"Cairo", lat:30.04, lon:31.23},
            {n:"Dubai", lat:25.20, lon:55.27}, {n:"London", lat:51.50, lon:-0.12},
            {n:"New York", lat:40.71, lon:-74.00}, {n:"Tokyo", lat:35.67, lon:139.65},
            {n:"Riyadh", lat:24.71, lon:46.67}, {n:"Moscow", lat:55.75, lon:37.61}
        ];

        const markersGroup = new THREE.Group();
        earthGroup.add(markersGroup);

        cities.forEach(city => {
            const pos = latLonToVector3(city.lat, city.lon, 5.01);
            const marker = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshBasicMaterial({color: 0x00ffcc}));
            marker.position.copy(pos);
            marker.userData = { isCity: true, ...city };
            markersGroup.add(marker);
        });

        // --- 5. INTERACTION & ACCURATE RAYCASTING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false, startPos = {x:0,y:0};

        const canvas = document.getElementById('canvas-container');
        canvas.addEventListener('mousedown', (e) => { isDragging=false; startPos={x:e.clientX,y:e.clientY}; });
        canvas.addEventListener('mousemove', (e) => { if(Math.abs(e.clientX-startPos.x)>5) isDragging=true; });
        canvas.addEventListener('mouseup', (e) => { if(!isDragging) onGlobeClick(e); });
        canvas.addEventListener('touchstart', (e) => { isDragging=false; startPos={x:e.touches[0].clientX,y:e.touches[0].clientY}; }, {passive:false});

        // --- FIXED: HIGH PRECISION CLICK LOGIC ---
        function onGlobeClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // 1. Check Markers
            const intersectsMarkers = raycaster.intersectObjects(markersGroup.children);
            if(intersectsMarkers.length > 0) {
                const data = intersectsMarkers[0].object.userData;
                if(data.isCity) {
                    document.getElementById('cityInput').value = data.n;
                    searchByCoords(data.lat, data.lon, true);
                    return;
                }
            }

            // 2. Check Earth (WITH MATH FIX)
            const intersects = raycaster.intersectObject(earth);
            if (intersects.length > 0) {
                const point = intersects[0].point;
                // Convert world point to local point (accounting for earth rotation)
                const localPoint = point.clone().applyMatrix4(earthGroup.matrixWorld.invert());
                const spherical = new THREE.Spherical().setFromVector3(localPoint);
                
                // Correct Lat/Lon conversion
                const lat = 90 - (spherical.phi * 180 / Math.PI);
                // **CRITICAL FIX**: Offset by -90 to align with Three.js texture mapping
                let lon = ((spherical.theta * 180 / Math.PI) - 90);
                
                // Wrap longitude to -180 to 180
                if (lon < -180) lon += 360;
                if (lon > 180) lon -= 360;

                showToast("ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖŸàŸÇÿπ...", "info");
                
                // Fetch real location name before weather
                fetchLocationName(lat, lon);
                searchByCoords(lat, lon, true);
            }
        }

        // --- 6. WEATHER LOGIC ---
        
        // REVERSE GEOCODING (Get Place Name)
        async function fetchLocationName(lat, lon) {
            try {
                // Free API for reverse geocoding
                const res = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=ar`);
                const data = await res.json();
                
                let name = data.city || data.locality || data.principalSubdivision || data.countryName || "ŸÖÿ≠Ÿäÿ∑ / ÿµÿ≠ÿ±ÿßÿ°";
                if(data.countryName && name !== data.countryName) name += `ÿå ${data.countryName}`;
                
                document.getElementById('uiCity').innerText = name;
                document.getElementById('cityInput').value = name;
            } catch(e) {
                console.log("Locality fetch failed", e);
                document.getElementById('uiCity').innerText = `Lat: ${lat.toFixed(1)} Lon: ${lon.toFixed(1)}`;
            }
        }

        window.locateUser = () => {
            showToast("ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿØŸäÿØ ŸÖŸàŸÇÿπŸÉ...", "info");
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        fetchLocationName(pos.coords.latitude, pos.coords.longitude);
                        searchByCoords(pos.coords.latitude, pos.coords.longitude);
                    },
                    () => fetchIPLocation()
                );
            } else fetchIPLocation();
        };

        async function fetchIPLocation() {
            try {
                const res = await fetch('https://ipapi.co/json/').then(r => r.json());
                fetchLocationName(res.latitude, res.longitude);
                searchByCoords(res.latitude, res.longitude);
            } catch(e) { showToast("ŸÅÿ¥ŸÑ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ", "error"); }
        }

        window.searchCity = async () => {
            const city = document.getElementById('cityInput').value;
            if(!city) return;
            try {
                showToast("ÿ®ÿ≠ÿ´...", "info");
                const geo = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${city}&count=1&language=ar&format=json`).then(r=>r.json());
                if(!geo.results) throw new Error("Not Found");
                
                // Update text properly
                document.getElementById('uiCity').innerText = geo.results[0].name;
                searchByCoords(geo.results[0].latitude, geo.results[0].longitude);
            } catch(e) { showToast("ŸÖÿØŸäŸÜÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©", "error"); }
        };

        async function searchByCoords(lat, lon, isClick = false) {
            if(isFetching) return;
            isFetching = true;
            controls.autoRotate = false;
            
            flyTo(lat, lon);
            addPulsePin(lat, lon);

            // API: USING ECMWF MODEL (European Centre for Medium-Range Weather Forecasts)
            // This is the "PRO" model for higher accuracy
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m,surface_pressure,visibility,is_day&hourly=temperature_2m,uv_index&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=auto&models=ecmwf_ifs04`;
            
            const aqiUrl = `https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${lat}&longitude=${lon}&current=us_aqi`;

            try {
                const [weatherRes, aqiRes] = await Promise.all([
                    fetch(url).then(r=>r.json()),
                    fetch(aqiUrl).then(r=>r.json())
                ]);
                updateUI(weatherRes, aqiRes, lat, lon);
            } catch(e) {
                console.error(e);
                showToast("ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™", "error");
            }
            isFetching = false;
            setTimeout(() => controls.autoRotate = true, 25000);
        }

        function updateUI(data, aqiData, lat, lon) {
            const cur = data.current;
            const daily = data.daily;
            const aqi = aqiData.current ? aqiData.current.us_aqi : 0;

            document.querySelectorAll('.panel').forEach(p => p.classList.add('active'));

            document.getElementById('coordsDisplay').innerText = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
            
            // Format Time based on Timezone
            const localTime = new Date().toLocaleTimeString('en-US', { timeZone: data.timezone, hour:'2-digit', minute:'2-digit', hour12: false });
            document.getElementById('localTime').innerText = localTime;
            
            document.getElementById('uiTemp').innerText = Math.round(cur.temperature_2m) + "¬∞";
            document.getElementById('uiDesc').innerText = getWeatherText(cur.weather_code);
            document.getElementById('wIcon').innerText = getWeatherIcon(cur.weather_code, cur.is_day);

            document.getElementById('uiWind').innerText = cur.wind_speed_10m + " km/h";
            document.getElementById('uiHum').innerText = cur.relative_humidity_2m + "%";
            document.getElementById('uiVis').innerText = (cur.visibility/1000).toFixed(1) + " km";
            
            const hourIndex = new Date().getHours();
            const uv = data.hourly.uv_index[hourIndex] || 0;
            document.getElementById('uiUV').innerText = uv.toFixed(1);

            const aqiEl = document.getElementById('aqiBadge');
            aqiEl.innerText = `AQI: ${aqi}`;
            aqiEl.style.color = aqi < 50 ? 'var(--aqi-good)' : (aqi < 100 ? 'var(--aqi-mod)' : 'var(--aqi-bad)');

            // FX
            const fx = document.getElementById('fx-layer');
            fx.className = '';
            if([51,53,55,61,63,65,80,81,82,95,96,99].includes(cur.weather_code)) fx.className = 'rain';
            if([71,73,75,85,86].includes(cur.weather_code)) fx.className = 'snow';

            updateChart(data.hourly);
            updateForecast(daily);
        }

        function updateForecast(daily) {
            const container = document.getElementById('forecastRow');
            container.innerHTML = '';
            for(let i=0; i<5; i++) {
                const date = new Date(daily.time[i]);
                const dayName = date.toLocaleDateString('ar-EG', {weekday: 'short'});
                const icon = getWeatherIcon(daily.weather_code[i], 1);
                const max = Math.round(daily.temperature_2m_max[i]);
                const div = document.createElement('div');
                div.className = 'day-card';
                div.innerHTML = `<div class="day-name">${dayName}</div><div class="day-icon">${icon}</div><div class="day-temp">${max}¬∞</div>`;
                container.appendChild(div);
            }
        }

        // --- 7. HELPER FUNCTIONS ---
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 90) * (Math.PI / 180); // Adjusted for visual offset
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        function flyTo(lat, lon) {
            // Target Rotation: We want to rotate the EARTH group so the point faces camera (Z-axis)
            // Latitude determines X rotation
            // Longitude determines Y rotation
            const targetX = lat * (Math.PI / 180);
            const targetY = -1 * (lon * (Math.PI / 180)) - (Math.PI / 2); // -90 deg offset
            
            new TWEEN.Tween(earthGroup.rotation)
                .to({ x: targetX, y: targetY }, 1500)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }

        function addPulsePin(lat, lon) {
            if(pin) earthGroup.remove(pin);
            pin = new THREE.Group();
            
            // Re-calculate pos based on corrected math
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 90) * (Math.PI / 180); // +90 offset for placement
            const radius = 5.0;
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            pin.position.set(x,y,z);
            pin.lookAt(0,0,0);

            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.01, 0.8, 8), new THREE.MeshBasicMaterial({color:0xff3366}));
            stem.rotation.x = Math.PI/2; stem.position.z = 0.4;
            
            const ring = new THREE.Mesh(new THREE.RingGeometry(0.1, 0.15, 32), new THREE.MeshBasicMaterial({color:0xff3366, side:2, transparent:true}));
            ring.position.z = 0.05; 
            
            pin.add(stem); pin.add(ring);
            earthGroup.add(pin);

            new TWEEN.Tween(ring.scale).to({x:6,y:6}, 1500).repeat(Infinity).start();
            new TWEEN.Tween(ring.material).to({opacity:0}, 1500).repeat(Infinity).start();
        }

        function updateChart(hourly) {
            const ctx = document.getElementById('weatherChart').getContext('2d');
            if(chartInstance) chartInstance.destroy();
            const gradient = ctx.createLinearGradient(0,0,0,150);
            gradient.addColorStop(0, 'rgba(79, 172, 254, 0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: hourly.time.slice(0, 12).map(t => t.slice(11, 16)),
                    datasets: [{
                        data: hourly.temperature_2m.slice(0, 12),
                        borderColor: '#4facfe', backgroundColor: gradient, fill: true, tension: 0.4, borderWidth: 2, pointRadius: 0
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: false, tooltip: {mode: 'index', intersect: false} },
                    scales: { x: { display:false }, y: { display:false } },
                    interaction: { mode: 'nearest', axis: 'x', intersect: false }
                }
            });
        }

        function getWeatherText(code) {
            const map = { 0:"ÿµÿßŸÅŸä", 1:"ÿ∫ÿßÿ¶ŸÖ ÿ¨ÿ≤ÿ¶Ÿä", 2:"ÿ∫ÿßÿ¶ŸÖ ÿ¨ÿ≤ÿ¶Ÿä", 3:"ÿ∫ÿßÿ¶ŸÖ", 45:"ÿ∂ÿ®ÿßÿ®", 48:"ÿ∂ÿ®ÿßÿ® ÿ¨ŸÑŸäÿØŸä", 51:"ÿ±ÿ∞ÿßÿ∞ ÿÆŸÅŸäŸÅ", 53:"ÿ±ÿ∞ÿßÿ∞ ŸÖÿ™Ÿàÿ≥ÿ∑", 55:"ÿ±ÿ∞ÿßÿ∞ ŸÉÿ´ŸäŸÅ", 61:"ŸÖÿ∑ÿ± ÿÆŸÅŸäŸÅ", 63:"ŸÖÿ∑ÿ± ŸÖÿ™Ÿàÿ≥ÿ∑", 65:"ŸÖÿ∑ÿ± ÿ∫ÿ≤Ÿäÿ±", 71:"ÿ´ŸÑŸàÿ¨ ÿÆŸÅŸäŸÅÿ©", 73:"ÿ´ŸÑŸàÿ¨ ŸÖÿ™Ÿàÿ≥ÿ∑ÿ©", 75:"ÿ´ŸÑŸàÿ¨ ŸÉÿ´ŸäŸÅÿ©", 95:"ÿπÿßÿµŸÅÿ© ÿ±ÿπÿØŸäÿ©", 96:"ÿπÿßÿµŸÅÿ© ÿ®ÿ±ÿØ", 99:"ÿπÿßÿµŸÅÿ© ÿ¥ÿØŸäÿØÿ©" };
            return map[code] || "ŸÖÿ™ŸÇŸÑÿ®";
        }
        function getWeatherIcon(c, d) {
            if(c===0) return d?"‚òÄÔ∏è":"üåô"; if(c<=3) return "‚òÅÔ∏è"; if(c<=67) return "üåßÔ∏è"; if(c<=77) return "‚ùÑÔ∏è"; return "‚ö°";
        }
        function showToast(m, t='info') {
            const c = document.getElementById('toastContainer');
            const el = document.createElement('div'); el.className=`toast ${t}`; el.innerText=m;
            c.appendChild(el); requestAnimationFrame(()=>el.classList.add('show'));
            setTimeout(()=>{el.classList.remove('show'); setTimeout(()=>el.remove(),500)},3000);
        }

        // Voice
        window.startVoice = () => {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            if(!SR) return showToast("ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑÿß ŸäÿØÿπŸÖ ÿßŸÑÿµŸàÿ™", "error");
            const r = new SR(); r.lang='ar-SA'; r.start();
            const b = document.getElementById('micBtn'); b.classList.add('recording');
            r.onresult = e => { document.getElementById('cityInput').value = e.results[0][0].transcript; searchCity(); b.classList.remove('recording'); };
            r.onerror = () => b.classList.remove('recording');
        };

        function animate(t) {
            requestAnimationFrame(animate);
            TWEEN.update(t);
            controls.update();
            clouds.rotation.y += 0.0002;
            atmosphere.material.uniforms.viewVector.value = new THREE.Vector3().subVectors(camera.position, atmosphere.position);
            renderer.render(scene, camera);
        }
        animate();

        window.onload = () => { setTimeout(() => document.getElementById('loader').style.opacity=0, 1000); setTimeout(()=>document.getElementById('loader').remove(), 1800); locateUser(); };
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
